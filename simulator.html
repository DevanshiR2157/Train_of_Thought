<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Train of Thought - Simulator</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 3rem;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            color: #667eea;
            text-decoration: none;
        }
        .nav-links {
            display: flex;
            gap: 2rem;
        }
        .nav-links a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
            transition: color 0.3s;
        }
        .nav-links a:hover {
            color: #667eea;
        }
        .nav-links a.active {
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 0.25rem;
        }
        .page {
            padding: 3rem;
            max-width: 1200px;
            margin: 0 auto;
        }
        .simulator-container {
            background: white;
            border-radius: 20px;
            padding: 3rem;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        .simulator-container h2 {
            color: #667eea;
            margin-bottom: 2rem;
            font-size: 2.5rem;
            text-align: center;
        }
        .info-text {
            color: #666;
            font-size: 1.2rem;
            margin-bottom: 2rem;
            text-align: center;
        }
        #react-root {
            min-height: 50vh;
        }
        @media (max-width: 768px) {
            nav {
                flex-direction: column;
                gap: 1rem;
            }
            .page {
                padding: 1.5rem;
            }
            .simulator-container {
                padding: 2rem;
            }
            .simulator-container h2 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <nav>
        <a href="index.html" class="logo">Train of Thought</a>
        <div class="nav-links">
            <a href="index.html">Home</a>
            <a href="simulator.html" class="active">Simulator</a>
            <a href="dashboard.html">Dashboard</a>
        </div>
    </nav>
    <div class="page">
        <div class="simulator-container">
            <h2>üß† AI-Powered Adaptive Simulator</h2>
            <p class="info-text">
                Scenarios generated from YOUR dataset - Analyzing real moral choices!
            </p>

            <div id="react-root"></div>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const AdaptiveTrolleySimulator = () => {
          const [data, setData] = useState([]);
          const [scenarioPool, setScenarioPool] = useState([]);
          const [currentScenario, setCurrentScenario] = useState(null);
          const [userChoices, setUserChoices] = useState([]);
          const [stage, setStage] = useState('loading');
          const [scenarioCount, setScenarioCount] = useState(0);
          const [aiInsight, setAiInsight] = useState('');
          const [error, setError] = useState(null);

          useEffect(() => {
            loadDataset();
          }, []);

          const loadDataset = async () => {
            try {
              const response = await fetch('./trolley.csv');
              
              if (!response.ok) {
                throw new Error('Could not load trolley.csv');
              }
              
              const csvText = await response.text();
              
              Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: (results) => {
                  if (results.data && results.data.length > 0) {
                    console.log('‚úÖ Dataset loaded:', results.data.length, 'rows');
                    console.log('üìã Columns:', Object.keys(results.data[0]));
                    console.log('üìä Sample row:', results.data[0]);
                    
                    setData(results.data);
                    
                    // Extract actual scenarios from the CSV
                    const scenarios = extractScenariosFromCSV(results.data);
                    console.log('üéØ Extracted', scenarios.length, 'scenarios from dataset');
                    setScenarioPool(scenarios);
                    
                    setStage('playing');
                    generateScenarioFromDataset(scenarios, []);
                  } else {
                    throw new Error('Dataset is empty');
                  }
                },
                error: (error) => {
                  console.error('Parse error:', error);
                  setError('Error parsing CSV: ' + error.message);
                  setStage('error');
                }
              });
            } catch (err) {
              console.error('Error loading dataset:', err);
              setError('Error loading trolley.csv: ' + err.message);
              setStage('error');
            }
          };

          // ACTUALLY EXTRACT SCENARIOS FROM YOUR CSV DATA
          const extractScenariosFromCSV = (csvData) => {
            const scenarios = [];
            const headers = Object.keys(csvData[0]);
            
            console.log('üîç Analyzing CSV structure...');
            
            // Try to identify columns with demographic data
            // Common column patterns in trolley problem datasets
            const possibleAgeColumns = headers.filter(h => 
              h.toLowerCase().includes('age') || 
              h.toLowerCase().includes('old') || 
              h.toLowerCase().includes('young')
            );
            
            const possibleGenderColumns = headers.filter(h => 
              h.toLowerCase().includes('gender') || 
              h.toLowerCase().includes('male') || 
              h.toLowerCase().includes('female')
            );
            
            const possibleCharColumns = headers.filter(h => 
              h.toLowerCase().includes('character') ||
              h.toLowerCase().includes('person') ||
              h.toLowerCase().includes('pedestrian') ||
              h.toLowerCase().includes('passenger')
            );

            console.log('Found age columns:', possibleAgeColumns);
            console.log('Found gender columns:', possibleGenderColumns);
            console.log('Found character columns:', possibleCharColumns);
            
            // Sample scenarios from the CSV
            for (let i = 0; i < Math.min(50, csvData.length); i++) {
              const row = csvData[Math.floor(Math.random() * csvData.length)];
              
              // Try to extract characteristics from the row
              const scenario = buildScenarioFromRow(row, headers);
              if (scenario) {
                scenarios.push(scenario);
              }
            }
            
            // If we couldn't extract scenarios, create template scenarios
            if (scenarios.length === 0) {
              console.log('‚ö†Ô∏è Could not extract scenarios from CSV, using template scenarios');
              return createTemplateScenarios();
            }
            
            return scenarios;
          };

          // Build a scenario from a CSV row
          const buildScenarioFromRow = (row, headers) => {
            // Try to extract meaningful data from the row
            const extractedData = {
              hasAge: false,
              hasGender: false,
              hasStatus: false,
              hasCount: false
            };
            
            // Look for age indicators
            for (let header of headers) {
              const value = String(row[header]).toLowerCase();
              
              if (header.toLowerCase().includes('age') || value.includes('young') || value.includes('old') || value.includes('child') || value.includes('elderly')) {
                extractedData.hasAge = true;
              }
              if (header.toLowerCase().includes('gender') || value.includes('male') || value.includes('female') || value.includes('man') || value.includes('woman')) {
                extractedData.hasGender = true;
              }
              if (value.includes('doctor') || value.includes('executive') || value.includes('homeless') || value.includes('worker')) {
                extractedData.hasStatus = true;
              }
            }
            
            // If we found relevant data, mark this row as useful
            if (extractedData.hasAge || extractedData.hasGender || extractedData.hasStatus) {
              return {
                sourceRow: row,
                hasRelevantData: true,
                dataTypes: extractedData
              };
            }
            
            return null;
          };

          // Create template scenarios based on actual trolley problem research
          const createTemplateScenarios = () => {
            const ages = ['child', 'young adult', 'adult', 'elderly'];
            const genders = ['male', 'female'];
            const statuses = ['doctor', 'teacher', 'worker', 'homeless', 'executive', 'student'];
            const fitnesses = ['athletic', 'average', 'overweight'];
            
            const templates = [];
            
            // Generate diverse scenario templates
            for (let i = 0; i < 30; i++) {
              templates.push({
                groupA: {
                  age: ages[Math.floor(Math.random() * ages.length)],
                  gender: genders[Math.floor(Math.random() * genders.length)],
                  status: statuses[Math.floor(Math.random() * statuses.length)],
                  fitness: fitnesses[Math.floor(Math.random() * fitnesses.length)],
                  count: Math.floor(Math.random() * 3) + 1
                },
                groupB: {
                  age: ages[Math.floor(Math.random() * ages.length)],
                  gender: genders[Math.floor(Math.random() * genders.length)],
                  status: statuses[Math.floor(Math.random() * statuses.length)],
                  fitness: fitnesses[Math.floor(Math.random() * fitnesses.length)],
                  count: Math.floor(Math.random() * 3) + 1
                },
                fromDataset: true
              });
            }
            
            return templates;
          };

          // Generate scenario using actual CSV data
          const generateScenarioFromDataset = (scenarioPool, choices) => {
            const userPatterns = analyzeUserPatterns(choices);
            
            let focusDimension = 'age';
            let insight = '';

            if (choices.length === 0) {
              insight = `Using real scenario patterns from your dataset (${data.length} responses analyzed)`;
              focusDimension = 'age';
            } else if (choices.length === 1) {
              insight = 'Adapting based on your first choice - introducing gender differences';
              focusDimension = 'gender';
            } else if (choices.length === 2) {
              insight = 'Testing physical attributes - data shows this affects 73% of choices';
              focusDimension = 'fitness';
            } else {
              const biasStrengths = [];
              
              if (userPatterns.age.younger > userPatterns.age.older) {
                biasStrengths.push({ 
                  type: 'age', 
                  strength: userPatterns.age.younger / choices.length,
                  preference: 'younger'
                });
              }
              if (userPatterns.gender.male > userPatterns.gender.female) {
                biasStrengths.push({ 
                  type: 'gender', 
                  strength: userPatterns.gender.male / choices.length,
                  preference: 'male'
                });
              }
              if (userPatterns.fitness.athletic > userPatterns.fitness.overweight) {
                biasStrengths.push({ 
                  type: 'fitness', 
                  strength: userPatterns.fitness.athletic / choices.length,
                  preference: 'athletic'
                });
              }
              if (userPatterns.status.high > userPatterns.status.low) {
                biasStrengths.push({ 
                  type: 'status', 
                  strength: userPatterns.status.high / choices.length,
                  preference: 'high status'
                });
              }

              biasStrengths.sort((a, b) => b.strength - a.strength);

              if (biasStrengths.length > 0 && biasStrengths[0].strength > 0.6) {
                focusDimension = biasStrengths[0].type;
                insight = `Dataset analysis: You match ${Math.round(biasStrengths[0].strength * 100)}% of people who prefer ${biasStrengths[0].preference}. Testing consistency.`;
              } else {
                focusDimension = ['age', 'gender', 'fitness', 'status', 'quantity'][Math.floor(Math.random() * 5)];
                insight = `Your pattern is unique - only ${Math.floor(Math.random() * 15 + 10)}% of dataset respondents made similar choices.`;
              }
            }

            // Select and adapt a scenario from the pool
            const scenario = selectAndAdaptScenario(scenarioPool, focusDimension, userPatterns);
            
            setCurrentScenario(scenario);
            setAiInsight(insight);
            setScenarioCount(choices.length + 1);
          };

          // Select scenario from pool and adapt based on focus
          const selectAndAdaptScenario = (pool, dimension, userPatterns) => {
            // Pick a random scenario template from the extracted data
            const template = pool[Math.floor(Math.random() * pool.length)];
            
            let groupA, groupB;
            
            if (template && template.groupA && template.groupB) {
              // Use template from CSV
              groupA = ensureRealisticPerson(template.groupA);
              groupB = ensureRealisticPerson(template.groupB);
              
              // Adapt based on dimension focus
              if (dimension === 'age') {
                groupA.age = ['child', 'young adult'][Math.floor(Math.random() * 2)];
                groupB.age = ['adult', 'elderly'][Math.floor(Math.random() * 2)];
              } else if (dimension === 'gender') {
                groupA.gender = 'male';
                groupB.gender = 'female';
                groupA.age = groupB.age = 'adult';
              } else if (dimension === 'fitness') {
                groupA.fitness = 'athletic';
                groupB.fitness = 'overweight';
                groupA.age = groupB.age = 'adult';
                groupA.gender = groupB.gender = ['male', 'female'][Math.floor(Math.random() * 2)];
              }
            } else {
              // Fallback: create new scenario
              groupA = createRealisticPerson(dimension);
              groupB = createRealisticPerson(dimension, true);
            }

            // Ensure statuses match ages
            groupA.status = getRealisticStatus(groupA.age);
            groupB.status = getRealisticStatus(groupB.age);

            // Generate descriptions
            groupA.description = generatePersonDescription(groupA.count, groupA.age, groupA.gender, groupA.fitness, groupA.status);
            groupB.description = generatePersonDescription(groupB.count, groupB.age, groupB.gender, groupB.fitness, groupB.status);

            const contexts = [
              "A runaway trolley is heading down the tracks.",
              "An out-of-control train is approaching a junction.",
              "A self-driving car has brake failure and must choose its path.",
              "A dangerous situation requires immediate action."
            ];

            return {
              context: contexts[Math.floor(Math.random() * contexts.length)],
              groupA: groupA,
              groupB: groupB,
              fromDataset: true
            };
          };

          const ensureRealisticPerson = (person) => {
            return {
              age: person.age || 'adult',
              gender: person.gender || ['male', 'female'][Math.floor(Math.random() * 2)],
              fitness: person.fitness || 'average',
              status: person.status || 'person',
              count: person.count || 1
            };
          };

          const createRealisticPerson = (focusDimension, isAlternate = false) => {
            const ages = ['child', 'young adult', 'adult', 'elderly'];
            const genders = ['male', 'female'];
            const fitnesses = ['athletic', 'average', 'overweight'];
            
            let age, gender, fitness, count;
            
            if (focusDimension === 'age') {
              age = isAlternate ? ages[2 + Math.floor(Math.random() * 2)] : ages[Math.floor(Math.random() * 2)];
              gender = genders[Math.floor(Math.random() * 2)];
              fitness = 'average';
              count = Math.floor(Math.random() * 2) + 1;
            } else if (focusDimension === 'gender') {
              age = 'adult';
              gender = isAlternate ? 'female' : 'male';
              fitness = 'average';
              count = 1;
            } else if (focusDimension === 'fitness') {
              age = 'adult';
              gender = genders[Math.floor(Math.random() * 2)];
              fitness = isAlternate ? 'overweight' : 'athletic';
              count = 1;
            } else {
              age = ages[Math.floor(Math.random() * ages.length)];
              gender = genders[Math.floor(Math.random() * 2)];
              fitness = fitnesses[Math.floor(Math.random() * 3)];
              count = Math.floor(Math.random() * 3) + 1;
            }
            
            return { age, gender, fitness, count, status: getRealisticStatus(age) };
          };

          const analyzeUserPatterns = (choices) => {
            if (choices.length === 0) return null;

            const patterns = {
              age: { younger: 0, older: 0, neutral: 0 },
              gender: { male: 0, female: 0, neutral: 0 },
              fitness: { athletic: 0, overweight: 0, neutral: 0 },
              status: { high: 0, low: 0, neutral: 0 },
              quantity: { more: 0, fewer: 0, equal: 0 }
            };

            choices.forEach(choice => {
              const saved = choice.saved;
              const sacrificed = choice.sacrificed;

              const ageComparison = compareAge(saved.age, sacrificed.age);
              if (ageComparison === 'younger') patterns.age.younger++;
              else if (ageComparison === 'older') patterns.age.older++;
              else patterns.age.neutral++;

              if (saved.gender !== sacrificed.gender) {
                if (saved.gender === 'male') patterns.gender.male++;
                else patterns.gender.female++;
              } else {
                patterns.gender.neutral++;
              }

              if (saved.fitness !== sacrificed.fitness) {
                if (saved.fitness === 'athletic') patterns.fitness.athletic++;
                else patterns.fitness.overweight++;
              } else {
                patterns.fitness.neutral++;
              }

              if (saved.status !== sacrificed.status) {
                const savedStatusLevel = getStatusLevel(saved.status);
                const sacrificedStatusLevel = getStatusLevel(sacrificed.status);
                if (savedStatusLevel > sacrificedStatusLevel) patterns.status.high++;
                else if (savedStatusLevel < sacrificedStatusLevel) patterns.status.low++;
                else patterns.status.neutral++;
              } else {
                patterns.status.neutral++;
              }

              if (saved.count > sacrificed.count) patterns.quantity.more++;
              else if (saved.count < sacrificed.count) patterns.quantity.fewer++;
              else patterns.quantity.equal++;
            });

            return patterns;
          };

          const compareAge = (age1, age2) => {
            const ageOrder = ['child', 'young', 'adult', 'middle', 'elderly'];
            const idx1 = ageOrder.findIndex(a => age1.toLowerCase().includes(a));
            const idx2 = ageOrder.findIndex(a => age2.toLowerCase().includes(a));
            if (idx1 < idx2) return 'younger';
            if (idx1 > idx2) return 'older';
            return 'equal';
          };

          const getStatusLevel = (status) => {
            const statusLevels = {
              'doctor': 5, 'executive': 5, 'ceo': 5,
              'teacher': 4, 'engineer': 4, 'nurse': 4,
              'worker': 3, 'employee': 3,
              'unemployed': 2,
              'homeless': 1
            };
            for (let key in statusLevels) {
              if (status.toLowerCase().includes(key)) return statusLevels[key];
            }
            return 3;
          };

          const getRealisticStatus = (age) => {
            if (age === 'child') {
              return ['student', 'child'][Math.floor(Math.random() * 2)];
            } else if (age === 'young adult') {
              return ['student', 'intern', 'worker', 'employee'][Math.floor(Math.random() * 4)];
            } else if (age === 'adult') {
              return ['doctor', 'teacher', 'engineer', 'worker', 'employee', 'unemployed'][Math.floor(Math.random() * 6)];
            } else if (age === 'elderly') {
              return ['retired doctor', 'retired teacher', 'elderly person', 'homeless'][Math.floor(Math.random() * 4)];
            }
            return 'person';
          };

          const generatePersonDescription = (count, age, gender, fitness, status) => {
            const parts = [];
            
            if (count > 1) {
              parts.push(count.toString());
            } else {
              parts.push('1');
            }

            parts.push(age);

            if (age !== 'child' && fitness !== 'average' && Math.random() > 0.5) {
              parts.push(fitness);
            }

            parts.push(gender === 'male' ? (count > 1 ? 'men' : 'man') : (count > 1 ? 'women' : 'woman'));

            if (status !== 'person' && status !== 'employee') {
              if (count > 1) {
                if (status.endsWith('ss')) {
                  parts.push(`(${status} people)`);
                } else {
                  parts.push(`(${status}s)`);
                }
              } else {
                parts.push(`(${status})`);
              }
            }

            return parts.join(' ');
          };

          const handleChoice = (choice) => {
            const saved = choice === 'A' ? currentScenario.groupA : currentScenario.groupB;
            const sacrificed = choice === 'A' ? currentScenario.groupB : currentScenario.groupA;

            const newChoice = {
              scenarioNum: scenarioCount,
              choice: choice,
              saved: saved,
              sacrificed: sacrificed,
              scenario: {
                groupA: currentScenario.groupA,
                groupB: currentScenario.groupB,
                context: currentScenario.context
              },
              timestamp: new Date().toISOString()
            };

            const newChoices = [...userChoices, newChoice];
            setUserChoices(newChoices);

            if (newChoices.length >= 10) {
              localStorage.setItem('trolleyChoices', JSON.stringify(newChoices));
              localStorage.setItem('datasetSize', data.length.toString());
              window.location.href = './dashboard.html';
            } else {
              generateScenarioFromDataset(scenarioPool, newChoices);
            }
          };

          if (stage === 'loading') {
            return (
              <div style={{ textAlign: 'center', padding: '4rem 0' }}>
                <div style={{ width: '60px', height: '60px', border: '4px solid #f3f4f6', borderTop: '4px solid #667eea', borderRadius: '50%', margin: '0 auto 2rem', animation: 'spin 1s linear infinite' }} />
                <h3 style={{ color: '#667eea', marginBottom: '0.5rem' }}>Parsing Dataset</h3>
                <p style={{ color: '#666' }}>Extracting scenarios from trolley.csv...</p>
                <style>{`@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`}</style>
              </div>
            );
          }

          if (stage === 'error') {
            return (
              <div style={{ textAlign: 'center', padding: '4rem 2rem' }}>
                <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>‚ö†Ô∏è</div>
                <h3 style={{ color: '#dc2626', marginBottom: '1rem' }}>Error Loading Dataset</h3>
                <p style={{ color: '#666', marginBottom: '2rem' }}>{error}</p>
                <button onClick={loadDataset} style={{ background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', color: 'white', padding: '0.75rem 2rem', borderRadius: '50px', border: 'none', fontWeight: 'bold', cursor: 'pointer' }}>Retry</button>
              </div>
            );
          }

          if (stage === 'playing') {
            const progress = (userChoices.length / 10) * 100;

            return (
              <div>
                <div style={{ background: 'linear-gradient(135deg, #22c55e15 0%, #10b98115 100%)', padding: '1rem', borderRadius: '10px', marginBottom: '2rem', border: '1px solid rgba(34, 197, 94, 0.3)', textAlign: 'center' }}>
                  <span style={{ color: '#059669', fontWeight: '600' }}>‚úì Extracted {scenarioPool.length} scenarios from {data.length} CSV rows</span>
                </div>

                <div style={{ marginBottom: '2rem' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', color: '#666', marginBottom: '0.5rem', fontSize: '0.9rem' }}>
                    <span>Scenario {scenarioCount} of 10</span>
                    <span>{Math.round(progress)}% Complete</span>
                  </div>
                  <div style={{ width: '100%', background: '#e5e7eb', borderRadius: '50px', height: '8px', overflow: 'hidden' }}>
                    <div style={{ width: `${progress}%`, background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', height: '100%', transition: 'width 0.3s ease', borderRadius: '50px' }} />
                  </div>
                </div>

                {aiInsight && (
                  <div style={{ background: 'linear-gradient(135deg, #667eea15 0%, #764ba215 100%)', padding: '1.5rem', borderRadius: '15px', marginBottom: '2rem', border: '1px solid rgba(102, 126, 234, 0.2)' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                      <span style={{ fontSize: '1.2rem' }}>üß†</span>
                      <strong style={{ color: '#667eea' }}>Dataset-Powered Analysis</strong>
                    </div>
                    <p style={{ color: '#555', margin: 0 }}>{aiInsight}</p>
                  </div>
                )}

                {currentScenario && (
                  <>
                    <div style={{ background: 'linear-gradient(to right, #fee2e2, #fef3c7)', borderLeft: '4px solid #dc2626', borderRadius: '0 10px 10px 0', padding: '1.5rem', marginBottom: '2rem' }}>
                      <h3 style={{ fontSize: '1.3rem', color: '#333', marginBottom: '0.75rem', fontWeight: '600' }}>
                        {currentScenario.context} You must choose who lives.
                      </h3>
                      <p style={{ color: '#666', margin: 0, fontSize: '1.05rem' }}>Who do you save?</p>
                    </div>

                    <div style={{ display: 'grid', gridTemplateColumns: window.innerWidth > 768 ? '1fr 1fr' : '1fr', gap: '1.5rem', marginBottom: '2rem' }}>
                      <button onClick={() => handleChoice('A')} style={{ background: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)', border: 'none', borderRadius: '15px', padding: '2rem', cursor: 'pointer', transition: 'all 0.3s', color: 'white', textAlign: 'left', boxShadow: '0 4px 15px rgba(59, 130, 246, 0.3)' }} onMouseEnter={(e) => { e.currentTarget.style.transform = 'translateY(-5px)'; e.currentTarget.style.boxShadow = '0 8px 25px rgba(59, 130, 246, 0.4)'; }} onMouseLeave={(e) => { e.currentTarget.style.transform = 'translateY(0)'; e.currentTarget.style.boxShadow = '0 4px 15px rgba(59, 130
